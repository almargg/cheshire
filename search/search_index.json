{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cheshire","text":"<p>Cheshire is a minimal Linux-capable host platform built around the RISC-V CVA6 core. Its goal is to provide a lightweight, configurable, autonomously booting host to systems that need one, from minimal Linux-capable SoCs to manycore compute accelerators.</p> <p>Cheshire is developed as part of the PULP project, a joint effort between ETH Zurich and the University of Bologna.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>To learn how to build and use Cheshire, see Getting Started.</li> <li>To learn about available simulation, FPGA, and ASIC targets, see Targets.</li> <li>For detailed information on Cheshire's inner workings, consult the User Manual.</li> </ul> <p>If you are impatient and have all needed dependencies, you can run <code>make all</code>, then start QuestaSim in <code>target/sim/vsim</code> and run:</p> <pre><code>set BINARY ../../../sw/tests/helloworld.spm.elf\nsource compile.tcl\nsource start.cheshire_soc.tcl\nrun -all\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Unless specified otherwise in the respective file headers, all code checked into this repository is made available under a permissive license. All hardware sources and tool scripts are licensed under the Solderpad Hardware License 0.51 (see <code>LICENSE</code>) with the exception of generated register file code (e.g. <code>hw/regs/*.sv</code>), which is generated by a fork of lowRISC's <code>regtool</code> and licensed under Apache 2.0. All software sources are licensed under Apache 2.0.</p>"},{"location":"#publication","title":"Publication","text":"<p>If you use Cheshire in your work, you can cite us:</p> <pre><code>@misc{ottaviano2023cheshire,\n      title         = {Cheshire: A Lightweight, Linux-Capable RISC-V Host\n                       Platform for Domain-Specific Accelerator Plug-In},\n      author        = {Alessandro Ottaviano and Thomas Benz and\n                       Paul Scheffler and Luca Benini},\n      year          = {2023},\n      eprint        = {2305.04760},\n      archivePrefix = {arXiv},\n      primaryClass  = {cs.AR}\n}\n</code></pre>"},{"location":"gs/","title":"Getting Started","text":"<p>We first discuss the Cheshire's project structure, its dependencies, and how to build it.</p>"},{"location":"gs/#repository-structure","title":"Repository structure","text":"<p>The project is structured as follows:</p> Directory Description Documentation <code>hw</code> Hardware sources as SystemVerilog RTL Architecture <code>sw</code> Software stack, build setup, and tests Software <code>target</code> Simulation, FPGA, and ASIC target setups Targets <code>util</code> Utility scripts <code>doc</code> Documentation Home"},{"location":"gs/#dependencies","title":"Dependencies","text":"<p>To build Cheshire, you will need:</p> <ul> <li>GNU Make <code>&gt;= 3.82</code></li> <li>Bender <code>&gt;= 0.27.1</code></li> <li>Python <code>&gt;= 3.9</code></li> <li>Python packages in <code>requirements.txt</code></li> <li>RISCV GCC <code>&gt;= 11.2.0</code></li> </ul> <p>Depending on your desired target, additional dependencies may be needed.</p>"},{"location":"gs/#building-cheshire","title":"Building Cheshire","text":"<p>To build different parts of Cheshire, run <code>make</code> followed by these targets:</p> <ul> <li><code>hw-all</code>: generated hardware, including IPs and boot ROM</li> <li><code>sw-all</code>: software running on our hardware</li> <li><code>sim-all</code>(\u2020): scripts and external models for simulation</li> <li><code>xilinx-all</code>: scripts for Xilinx FPGA implementation</li> </ul> <p>\u2020 <code>sim-all</code> will download externally provided peripheral simulation models, some proprietary and with non-free license terms, from their publically accessible sources; see <code>Makefile</code> for details. By running <code>sim-all</code> or the default target <code>all</code>, you accept this.</p> <p>Running <code>hw-all</code> is required at least once to correctly configure IPs we depend on. On reconfiguring any generated hardware or changing IP versions, <code>hw-all</code> should be rerun.</p> <p>To run all build targets above (\u2020):</p> <pre><code>make all\n</code></pre> <p>The following additional targets are not invoked by the above, but also available:</p> <ul> <li><code>bootrom-all</code>: Rebuilds the boot ROM. This is not done by default as reproducible builds (as checked by CI) can only be guaranteed for fixed compiler versions.</li> <li><code>nonfree-init</code>: Clones our internal repository with nonfree resources we cannot release, including our internal CI. This is not necessary to use Cheshire.</li> <li><code>clean-deps</code>: Removes checked-out bender dependencies and submodules. This is useful if references to dependencies are updated.</li> </ul>"},{"location":"gs/#targets","title":"Targets","text":"<p>A target is an end use for Cheshire. Each target requires different steps from here; read the page for your desired target in the following Targets chapter.</p>"},{"location":"tg/","title":"Targets","text":"<p>A target refers to an end use of Cheshire. This could be a simulation setup, an FPGA or ASIC implementation, or the integration into other SoCs.</p> <p>Target setups can either be included in this repository or live in an external repository and use Cheshire as a dependency.</p>"},{"location":"tg/#included-targets","title":"Included Targets","text":"<p>Included target setups live in the <code>target</code> directory. The associated make targets <code>&lt;target&gt;-all</code>  set up necessary resources and scripts before use.</p> <p>Each included target has a documentation page in this chapter:</p> <ul> <li>Simulation</li> <li>Xilinx FPGAs</li> </ul>"},{"location":"tg/#external-targets","title":"External Targets","text":"<p>For integration into other SoCs, Cheshire may be included either as a Bender dependency or Git submodule. For further information and best pratices, see SoC Integration.</p>"},{"location":"tg/integr/","title":"SoC Integration","text":"<p>Cheshire is designed to be highly configurable and provide host and interconnect infrastructure for systems on various scales. Examples of SoCs integrating Cheshire are:</p> <ul> <li>Iguana, an minimal end-to-end open-source Linux-capable SoC built with open tools.</li> <li>Carfield, a mixed-criticality SoC targeting the automotive domain.</li> </ul>"},{"location":"tg/integr/#using-cheshire-in-your-project","title":"Using Cheshire In Your Project","text":"<p>As for internal targets, Cheshire must be built before use in external projects. We aim to simplify this as much as possible with a portable make fragment.</p> <p>If you use GNU Make to build your project and Bender to handle dependencies, you can include the Cheshire build system into your own Makefile with:</p> <pre><code>include $(shell bender path cheshire)/cheshire.mk\n</code></pre> <p>All of Cheshire's build targets are now available with the prefix <code>chs-</code>. You can leverage this to ensure your Cheshire build is up to date and rebuild hardware and software whenever necessary. You can change the default value of any build parameter, replace source files to adapt Cheshire, or reuse parts of its build system, such as the software stack or the register and ROM generators.</p>"},{"location":"tg/integr/#instantiating-cheshire","title":"Instantiating Cheshire","text":""},{"location":"tg/sim/","title":"Simulation","text":"<p>This page describes how to simulate Cheshire to execute baremetal code. Please first read Getting Started to make sure to make sure have all dependencies and built the hardware, software, and simulation scripts.</p> <p>We currently provide working setups for:</p> <ul> <li>Questa Advanced Simulator (QuestaSim) <code>&gt;= 2022.3</code></li> </ul> <p>We plan on supporting more simulators in the future. If your situation requires it, simulating Cheshire on other setups should be straightforward.</p>"},{"location":"tg/sim/#testbench","title":"Testbench","text":"<p>We provide a SystemVerilog testbench for <code>cheshire_soc</code> running baremetal code. This code is either preloaded through simulated interface drivers or read from external memory models by the boot ROM and then executed, depending on how the  <code>PRELMODE</code> and <code>BOOTMODE</code> variables are set:</p> <code>BOOTMODE</code> <code>PRELMODE</code> Action 0 0 Preload through JTAG 0 1 Preload through serial link 0 2 Preload through UART 1-3 - Autonomous boot, see Boot ROM <p>Preloading boot modes expect an ELF executable to be passed through <code>BINARY</code>, while autonomous boot modes expect a disk image (GPT formatted or raw code) to be passed through <code>IMAGE</code>. For more information on how to build software for Cheshire and its boot process, see Software.</p> <p>For simulation of Cheshire in other designs, we provide the module <code>cheshire_vip</code> encapsulating all verification IPs and their interfaces.</p>"},{"location":"tg/sim/#questasim","title":"QuestaSim","text":"<p>After building Cheshire, start QuestaSim in <code>target/sim/vsim</code> and run:</p> <pre><code># Preload `helloworld.spm.elf` through serial link\nset BINARY ../../../sw/tests/helloworld.spm.elf\nset BOOTMODE 0\nset PRELMODE 1\n\n# Compile design\nsource compile.tcl\n\n# Start and run simulation\nsource start.cheshire_soc.tcl\nrun -all\n</code></pre> <p>The design needs to be recompiled only when hardware is changed. The simulation can be restarted by re-sourcing <code>start.cheshire_soc.tcl</code>, allowing binary (or image) and load method changes beforehand.</p>"},{"location":"tg/xilinx/","title":"Xilinx FGPAs","text":"<p>This page describes how to map Cheshire on Xilinx FPGAs to execute baremetal code or boot CVA6 Linux. Please first read Getting Started to make sure have all dependencies and built the hardware, software, and Xilinx FPGA scripts. Additionally, for on-chip debugging you need:</p> <ul> <li>OpenOCD <code>&gt;= 0.10.0</code></li> </ul> <p>We currently provide working setups for:</p> <ul> <li>Digilent Genesys 2 with Vivado <code>&gt;= 2020.2</code></li> </ul> <p>We are working on support for more boards in the future.</p>"},{"location":"tg/xilinx/#implementation","title":"Implementation","text":"<p>Since the implementation steps and available features vary between boards, we provide instructions and document available features for each.</p>"},{"location":"tg/xilinx/#digilent-genesys-2","title":"Digilent Genesys 2","text":"<p>Generate the bitstream <code>target/xilinx/out/cheshire_top_xilinx.bit</code> by running:</p> <pre><code>make -C target/xilinx\n</code></pre> <p>Before flashing the bitstream to your device, take note of the position of onboard switches, which control important functionality:</p> Switch Function 1 .. 0 Boot mode; see Boot ROM 5 .. 2 Fan level; do not keep at 0 7 Test mode; leave at zero <p>The reset, JTAG TAP, UART, I2C, and VGA are all connected to their onboard logic or ports. The UART has no flow control. The microSD slot is connected to chip select 0 of the SPI host peripheral. Serial link and GPIOs are currently not available.</p>"},{"location":"tg/xilinx/#debugging-with-openocd","title":"Debugging with OpenOCD","text":"<p>To establish a debug bridge over JTAG, ensure the target is in a debuggable state (for example by resetting into the idle boot mode 0) and launch OpenOCD with:</p> <pre><code>openocd -f $(bender path ariane)/corev_apu/fpga/ariane.cfg\n</code></pre> <p>In another shell, launch a RISC-V GDB session attaching to OpenOCD:</p> <pre><code>riscv64-unknown-elf-gdb -ex \"target extended-remote localhost:3333\"\n</code></pre> <p>You can now interrupt (Ctrl+C), inspect, and repoint execution with GDB as usual. Note that resetting the board during debug sessions is not supported. If the debug session dies or you need to reset the board for another reason:</p> <ol> <li>Terminate GDB and OpenOCD</li> <li>Reset the board</li> <li>Relaunch OpenOCD, then GDB.</li> </ol>"},{"location":"tg/xilinx/#running-baremetal-code","title":"Running Baremetal Code","text":"<p>Baremetal code can be preloaded through JTAG using OpenOCD and GDB or loaded from an SD Card. In principle, other interfaces may also be used to boot if the board provides them, but no setups are available for this.</p> <p>First, connect to UART using a serial communication program like minicom:</p> <pre><code>minicom -cD /dev/ttyUSBX\n</code></pre> <p>Make sure that hardware flow control matches your board's setup (usually off).</p> <p>In the following examples, we will use the <code>helloworld</code> test. As in simulation, you can replace this with any baremetal program of your choosing or design; see Baremetal Programming.</p>"},{"location":"tg/xilinx/#jtag-preloading","title":"JTAG Preloading","text":"<p>Start a debug session in the project root and enter in GDB:</p> <pre><code>load sw/tests/helloworld.spm.elf\ncontinue\n</code></pre> <p>You should see <code>Hello World!</code> output printed on the UART.</p>"},{"location":"tg/xilinx/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>First, build an up-to-date a disk image for your desired binary. For <code>helloworld</code>:</p> <pre><code>make sw/tests/helloworld.gpt.bin\n</code></pre> <p>Then flash this image to an SD card (note that this requires root privileges):</p> <pre><code>sudo dd if=sw/tests/helloworld.gpt.bin of=/dev/&lt;sdcard&gt;\nsudo sgdisk -e /dev/&lt;sdcard&gt;\n</code></pre> <p>The second command only ensures correctness of the partition layout; it moves the secondary GPT header at the end of the minimally sized image to the end of your actual SD card.</p> <p>Insert your SD card and reset into boot mode 1. You should see a <code>Hello World!</code> UART output.</p>"},{"location":"tg/xilinx/#booting-linux","title":"Booting Linux","text":"<p>To boot Linux, we must load the OpenSBI firmware, which takes over M mode and launches the U-boot bootloader. U-boot then loads Linux. For more details, see Boot Flow.</p> <p>Clone the <code>cheshire</code> branch of CVA6 SDK and build the firmware (OpenSBI + U-boot) and Linux images (this will take about 30 minutes):</p> <pre><code>git submodule update --init --recursive sw/deps/cva6-sdk\nmake -C sw/deps/cva6-sdk images\n</code></pre> <p>In principle, we can boot Linux through JTAG by loading all images into memory, launching OpenSBI, and instructing U-boot to load the kernel directly from memory. Here, we focus on autonomous boot from SD card.</p> <p>In this case, OpenSBI is loaded by a regular baremetal program called the Zero-Stage Loader (ZSL). The boot ROM loads the ZSL from SD card, which then loads the device tree and firmware from other SD card partitions into memory and launches OpenSBI.</p> <p>To create a full Linux disk image from the ZSL, device tree, firmware, and Linux, run:</p> <pre><code>make sw/boot/linux.gpt.bin\n</code></pre> <p>Flash this image to an SD card as you did in the previous section, then insert the SD card and reset into boot mode 1. You should first see the ZSL print on the UART:</p> <pre><code> /\\___/\\       Boot mode:       1\n( o   o )      Real-time clock: ... Hz\n(  =^=  )      System clock:    ... Hz\n(        )     Read global ptr: 0x...\n(    P    )    Read pointer:    0x...\n(  U # L   )   Read argument:   0x...\n(    P      )\n(           ))))))))))\n</code></pre> <p>You should then boot through OpenSBI, U-Boot, and Linux until you are dropped into a shell.</p>"},{"location":"um/","title":"User Manual","text":""},{"location":"um/arch/","title":"Architecture","text":""},{"location":"um/arch/#memory-map","title":"Memory Map","text":"<p>Block</p> <p>Device</p> <p>Start</p> <p>Size</p> <p>Flags</p> <p>256K periphs @ AXI</p> <p>Debug ROM</p> <p>0x0000_0000</p> <p>256K</p> <p>E</p> <p>4K periphs @ AXI</p> <p>AXI DMA (Cfg)</p> <p>0x0100_0000</p> <p>4K</p> <p>256K periphs @ Reg</p> <p>Boot ROM</p> <p>0x0200_0000</p> <p>256K</p> <p>E</p> <p>(A)CLINT(s)</p> <p>0x0204_0000</p> <p>256K</p> <p>CLIC</p> <p>0x0208_0000</p> <p>256K</p> <p>IRQ router</p> <p>0x0210_0000</p> <p>256K</p> <p>4K periphs @ Reg</p> <p>Regs</p> <p>0x0300_0000</p> <p>4K</p> <p>LLC (Cfg)</p> <p>0x0300_1000</p> <p>4K</p> <p>UART</p> <p>0x0300_2000</p> <p>4K</p> <p>I2C</p> <p>0x0300_3000</p> <p>4K</p> <p>SPI Host</p> <p>0x0300_4000</p> <p>4K</p> <p>GPIO</p> <p>0x0300_5000</p> <p>4K</p> <p>Serial Link (Cfg)</p> <p>0x0300_6000</p> <p>4K</p> <p>VGA (Cfg)</p> <p>0x0300_7000</p> <p>4K</p> <p>AXI RT</p> <p>0x0300_8000</p> <p>4K</p> <p>PLIC @ Reg</p> <p>PLIC</p> <p>0x0400_0000</p> <p>64M</p> <p>SPM @ AXI</p> <p>cached</p> <p>0x1000_0000</p> <p>64M</p> <p>CIE</p> <p>uncached</p> <p>0x1400_0000</p> <p>64M</p> <p>IE</p> <p>External</p> <p>CIE</p> <p>0x2000_0000</p> <p>512M</p> <p>CIE</p> <p>non-CIE</p> <p>0x4000_0000</p> <p>1G</p> <p>LLC out (DRAM)</p> <p>0x8000_0000</p> <p>?</p> <p>CIE</p>"},{"location":"um/arch/#boot-rom","title":"Boot ROM","text":""},{"location":"um/sw/","title":"Software","text":""},{"location":"um/sw/#boot-flow","title":"Boot Flow","text":""},{"location":"um/sw/#linux","title":"Linux","text":""},{"location":"um/sw/#baremetal-programming","title":"Baremetal programming","text":""}]}